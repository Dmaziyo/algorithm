## 计算机网络 面试知识点总结

### 目录

- [计算机网络 面试知识点总结](#计算机网络-面试知识点总结)
  - [目录](#目录)
    - [1. 设置了强制缓存后,如何更新资源](#1-设置了强制缓存后如何更新资源)
    - [2. 从输入 url 到浏览器出现画面的过程](#2-从输入-url-到浏览器出现画面的过程)
    - [3. csrf 攻击](#3-csrf-攻击)
    - [4. 什么是浏览器的同源策略,如何处理](#4-什么是浏览器的同源策略如何处理)
    - [5. HTTP1.0 到 3.0 的变化](#5-http10-到-30-的变化)
    - [6.什么是网络模型，为什么要有网络分层模型？](#6什么是网络模型为什么要有网络分层模型)
    - [7.什么是websocket，为什么会出现？](#7什么是websocket为什么会出现)
    - [8.HTTP 报文结构是怎样的？](#8http-报文结构是怎样的)
    - [9.如何理解HTTP的请求方法](#9如何理解http的请求方法)

#### 1. 设置了强制缓存后,如何更新资源

```js
    强制缓存的expires 或者 Cache-Control 中设置的时间过期后,才会去更新资源
```

#### 2. 从输入 url 到浏览器出现画面的过程

[[键入网址到网页显示，期间发生了什么?]](https://xiaolincoding.com/network/1_base/what_happen_url.html)[[你不知道的浏览器页面渲染机制]](https://juejin.cn/post/6844903815758479374#heading-9)

```js
    1.浏览器首先解析url,确定服务器和资源路径,生成发送给服务器的请求报文
    2.通过DNS查询服务器域名对应的真实ip地址
    3.与服务器建立TCP连接,利用TCP/IP协议栈将数据包发送至服务器
    4.服务器接收到请求报文后,将响应报文发送至客户端
    5.浏览器将响应报文进行解析,将HTML生成DOM tree,CSS 解析成 css rule tree,用于将样式匹配到对应元素上去
    6.DOM tree 和 CSS rule tree 会组合在一起形成render tree,里面只包含了要显示的元素,而display:none这样的不会出现在render tree中
    7.浏览器根据render tree 计算出大致的layout,然后再将layout实际渲染出来
```

#### 3. csrf 攻击

[前端安全系列之二：如何防止 CSRF 攻击?](https://juejin.cn/post/6844903689702866952#heading-5)

```js
    CSRF(cross site request forgery):利用用户本地存储的验证信息,来绕过被攻击者网站的验证,进行相应的攻击操作
    流程:
        1.用户登录被攻击网站,存储了登录验证信息(cookie)
        2.hacker引诱用户在不知觉的情况下访问被攻击网站(通过第三方网站或者图片链接)
        3.被攻击者网站验证身份通过,执行对应操作
        4.最终hacker冒充用户在被攻击网站执行了操作
    实现方式:img跨域加载请求,form提交,超链接
    防护策略:
        - 同源策略:在访问url时,验证访问的来源,利用origin或者referer
        - 利用token来进行用户的验证(每次请求时需要附带一个token,而token放在攻击者无法获取的位置)
```

#### 4. 什么是浏览器的同源策略,如何处理

[浏览器同源政策及其规避方法](http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html)

```js
在协议 + 域名 + 端口号不同的情况下, 浏览器会对js进行一些限制
- js不能访问其他域名下的cookie，localStorage，indexDB．
- ajax请求只能发给同源地址.
// 规避同源机制的方法
- 使用代理服务器，因为服务器之前的请求没有同源策略
- JSONP 只支持get请求
- CORS  现代浏览器在请求时会在请求头添加origin,让服务器进行判断是否能够返回数据
```

#### 5. HTTP1.0 到 3.0 的变化

```js
review:√
1.0阶段：
    - 客户端向服务器请求资源只能逐个请求(可能会造成阻塞)，不能并发请求
    - 每次请求完后连接就会断开，之后再请求需要重新建立TCP连接
    - 请求头和请求体都是文本形式
1.1阶段：
    - 增加了长连接,通过请求头添加字段“Connection: keep-alive”（原理是定时发包确认是否正常运行，直到一方断开连接才关闭）
    - 支持管道传输，在发送完一个请求后，可以接着发下一个
2.0阶段：
    - 将报文变成了二进制的帧形式，并且分成了头信息帧和数据信息帧
    - 头信息帧可以进行压缩，会将重复的头部信息帧放入一个索引表中，而发送的时候只需要传输索引值即可，双方共同维护索引表

    - 并行传输，引入了stream的概念，stream是一个资源请求或响应的分块。而块中包含了许多帧，每个资源请求和响应对应一个id，最终通过id来有序组装
    - 服务器推送功能，当客户端请求了一个html文件时，服务器可以推送相关的css和js文件
  缺点： 因为是2.0是基于TCP实现的，所以在发送一组数据包的时候，如果其中有一个未收到，则会等待直至收到为止，之后再将数据包交给应用层，也会有阻塞情况
3.0阶段：大致就是在http内部实现了一个TCP重传机制，而在传输层采用udp协议，避免阻塞
```
#### 6.什么是网络模型，为什么要有网络分层模型？
```
因为实现计算机网络是错综复杂的，需要考虑很多因素，而网络模型就是将各自因素分类提取，使得每个层次只需要考虑自身的功能即可,无需在意其他层的功能实现，各层只需要调用下层接口，为上层提供服务接口即可
```

#### 7.什么是websocket，为什么会出现？
```
出发点：
    1.实现主动弹出一个广告，可以采用http不断轮询,进而等待服务器返回弹窗相关信息
    2.在网页上玩一个游戏，怪物的移动，其他玩家的移动，需要通过服务器主动推送给玩家,也可以使用不断轮询的方式来获取实时数据
    3.二维码的扫描,也可以通过不断轮询来实时判断是否扫描成功
综上情况都是使用了http不断轮询扫描来实现的

为什么服务器不主动推送呢?
因为目前大部分场景我们都是使用http1.1，而http1.1是一个客户端一个服务端，所以是半双工，即同一时间，只有一方能发送数据,因此想要实现上述功能只能不断轮询

websocket的特点:可以在客户端和服务端实现全双工
建立过程是基于http实现的，但并不依赖于http,只是利用http协议，在其中header中加上一些特殊头来进行升级，实现websocket
建立过程：
    1.首先基于tcp协议，第一次使用http协议进行通信
    2.在第一次http协议通信过程中，会在请求头header字段添加一些特殊请求头
    3.若服务器支持升级，则会在响应头里添加字段Sec-WebSocket-Accept用来给客户端验证并且状态码为101，表示协议升级
    4.浏览器再将字段的base64码转换成字符串来验证，验证成功则双方之后使用websocket的数据格式通信
```
#### 8.HTTP 报文结构是怎样的？
```
构成结构：
---起始行---   
---头部 ---
---空行 ---
---实体 ---

起始行：
    请求报文：请求方法+路径+http版本  GET/home HTTP/1.1
    响应报文: http版本+状态码+原因    HTTP/1.1 200 OK
头部：
    field Name : Field Value      //遵循键值对的模式
空行：用于区分头部和实体
实体:请求报文对应请求体，响应报文对应响应体
```
#### 9.如何理解HTTP的请求方法
```
GET：用来获取资源
HEAD：获取资源的元信息
POST：提交数据，即上传数据
PUT：修改数据
DELETE：删除数据
CONNECT：建立连接隧道，用于代理服务器
OPTIONS：查询对资源可实施的请求方法
TRACE：追踪请求-响应的传输路径
```